function pp = prep_template(filename)
% function pp = prep_template(filename)
%
% Save template for image pre-processing parameter file to specified path
% 
% Arguments:
% 
%   filename: string, path to output JSON file 
% %

update_path('util');

if nargin > 0
    [~, ~, ext] = fileparts(filename);
    assert(strcmp(ext, '.mat'), 'Filename must have extension .mat');
end

% general --------

pp.notes.help = 'string, any notes to be included in the results file for posterity';
pp.notes.value = '';

% images ---------

pp.view.help = "string, specify 'side' or 'top' image view";
pp.view.value = 'side';

pp.image_dir.help = "string, directory containing all image files";
pp.image_dir.value = ""; 

pp.woco_file.help = "string, world coordinate image filename (without directory)";
pp.woco_file.value = "";

pp.exp_files.help = "list of strings, all experiment image filenames (without directory), assumed to be ordered by time";
pp.exp_files.value = [];

% woco ----------

pp.woco_xw.help = "1D vector, x-position of control points in world coordinates";
pp.woco_xw.value = [];

pp.woco_yw.help = "1D vector, x-position of control points in world coordinates";
pp.woco_yw.value = [];

pp.woco_xp.help = "1D vector, x-position of control points in pixel coordinates";
pp.woco_xp.value = [];

pp.woco_yp.help = "1D vector, x-position of control points in pixel coordinates";
pp.woco_yp.value = [];

% crop and rectify ----------

pp.crop_xlim.help = "2-element array, minimum and maximum x coordinates for crop in world coordinate units (m)";
pp.crop_xlim.value = [-0.6, 0.6];

pp.crop_ylim.help = "2-element array, minimum and maximum y coordinates for crop in world coordinate units (m)";
pp.crop_ylim.value = [0.0, 0.2];

% masking ----------

pp.mask_segment_scale.help = 'Scalar, parameter to Felzenswalb segmentation, free parameter, higher means larger clusters';
pp.mask_segment_scale.value = 25;

pp.mask_segment_sigma.help = 'Scalar, parameter to Felzenswalb segmentation, width of Gaussian kernel used in preprocessing';
pp.mask_segment_sigma.value = 0.5;

p.mask_segment_min_size.help = 'Scalar, parameter to Felzenswalb segmentation, minimum component size';
p.mask_segment_min_size.value = 50;

pp.mask_train_file.help = "string, filename (without directory) of image to use for mask model training data";
pp.mask_train_file.value = '';

pp.mask_train_features.help = "2D array, num_segments x num_features, training features generated by summarizing segmented training image";
pp.mask_train_features.value = [];

pp.mask_train_labels.help = "1D array of length num_segments, labels for training features, 0 = unclassified, 1 = sand, 2 = other (not sand)";
pp.mask_train_labels.value = [];

pp.mask_model_type.help = "string, select mask model from a few options: 'tree' uses a simple decision tree (relatively fast for development), and 'forest' uses a slower, better random forest model.";
pp.mask_model_type.value = 'tree';

% color adjustment ----------

pp.intensity_eql_len.help = "scalar, integer, odd. Side length (in pixels) for the local neighborhood used to compute the transform for each pixel";
pp.intensity_eql_len.value = 41;

% save as file ---

if nargin > 0
    save_param(pp, filename);
end