function [] = test_piv_run_image(varargin)
%
% Test PIV performance using case using synthetic image pair generated by
% homogenous deformation and translation of a single input image.
%
% Optional Arguments ('Name', Value):
%   'image_file': String, name of pre-processed image file, as produced by
%       prep_series(), to read for raw image, default = ./test/default_image.nc
%   'image_index': Integer, (1-based) index of image in image file to use for
%       raw image, default = 1
%   'image_pos': 4-element position vector indicating the limits of the image to
%       extract and deform. Must contain only sand (all within the ROI),
%       in meters, default = [-0.12, 0.005, 0.092, 0.07]
%   'translation': 2-element vector specifying spatially constant translation
%       in meters, default = [0.005, 0.00]
%   'shear_theta': Scalar, orientation of shear band specified as
%       counter-clockwise angle to the positive x-axis, in degrees, limited to
%       range 0 - 90, default = 45
%   'shear_width': Scalar, width of shear band, in meters, default = 0.05   
%   'shear_mag': Scalar, displacement difference across shear band, applied as a
%       0.5*shear_mag displacement on one side and a -0.5*shear_mag displacement
%       on the other, default = sqrt(2)*0.005
%   'bnd_mean': Mean position of the upper boundary imposed on the image, as a
%       fraction of the image height, default = 0.95
%   'bnd_ampl': Mean amplitude of sinusoidal upper boundary imposed on the
%       image, as a fraction of the image height, default = 0.1
%   'bnd_freq': Frequency of sinusoidal upper boundary imposed on the image, as
%       a fraction of the image width, default = 1
%
% %

% TODO: make the piv parameters inputs with default values

%% parse arguments

% constants
src_dir = fileparts(mfilename('fullpath'));

ip = inputParser();

ip.addParameter('image_file', fullfile(src_dir, 'test', 'default_image.nc'), ...
    @(x) exist(x, 'file') == 2);
ip.addParameter('image_index', 1, ...
    @(x) validateattributes(x, {'numeric'}, {'scalar', 'integer', 'positive'}));
ip.addParameter('image_pos', [-0.12, 0.005, 0.092, 0.07], ...
    @(x) validateattributes(x, {'numeric'}, {'vector', 'numel', 4}));
ip.addParameter('translation', [0.005, 0.00], ...
    @(x) validateattributes(x, {'numeric'}, {'vector', 'numel', 2}));
ip.addParameter('shear_theta', 45, ...
    @(x) validateattributes(x, {'numeric'}, {'scalar', 'min', 0, 'max' 90}));
ip.addParameter('shear_width', 0.05, ...
    @(x) validateattributes(x, {'numeric'}, {'scalar', 'positive'}));
ip.addParameter('shear_mag', 0.01, ...
    @(x) validateattributes(x, {'numeric'}, {'scalar', 'positive'}));
ip.addParameter('bnd_mean', 0.95, ...
    @(x) validateattributes(x, {'numeric'}, {'scalar', 'min', 0, 'max', 1}));
ip.addParameter('bnd_ampl', 0.05, ...
    @(x) validateattributes(x, {'numeric'}, {'scalar', 'min', 0, 'max', 1}));
ip.addParameter('bnd_freq', 1, ...
    @(x) validateattributes(x, {'numeric'}, {'scalar', 'positive'}));

% % piv parameters
% samplen = [30, 30];
% sampspc = [15, 15];
% intrlen = [100, 60];
% npass = [1, 2];
% valid_max = 2;
% valid_eps = 0.1;
% spline_tension = 0.95;
% min_frac_data = 0.8;
% min_frac_overlap = 0.5;

ip.parse(varargin{:});
args = ip.Results;

% <DEBUG>
disp(args)
% </DEBUG>

%% read and crop raw image

xx = double(ncread(args.image_file, 'x'));
yy = double(ncread(args.image_file, 'y'));
img = double(ncread(args.image_file, 'img', [1, 1, args.image_index], [inf, inf, 1]));
mask_auto = ncread(args.image_file, 'mask_auto', [1, 1, args.image_index], [inf, inf, 1]);
mask_manu = ncread(args.image_file, 'mask_manual');
roi = mask_auto & mask_manu;

min_col = find(xx >= args.image_pos(1), 1, 'first');
max_col = find(xx <= args.image_pos(1) + args.image_pos(3), 1, 'last');
min_row = find(yy >= args.image_pos(2), 1, 'first');
max_row = find(yy <= args.image_pos(2) + args.image_pos(4), 1, 'last');

xx = xx(min_col:max_col);
yy = yy(min_row:max_row);
img = img(min_row:max_row, min_col:max_col);
roi = roi(min_row:max_row, min_col:max_col);

if any(~roi(:))
    error('%s: image_pos limits must include only sand (ROI)', mfilename);
end

%% pad image boundaries (and coordinates) to accomodate edge displacements

padsize = ceil(0.10*size(img));
img = padarray(img, padsize, 0, 'both');
roi = padarray(roi, padsize, 0, 'both');
dx = mean(diff(xx));
xx = [xx(1)-dx*(padsize(2):-1:1), xx(:)', xx(end)+dx*(1:padsize(2))];
dy = mean(diff(yy));
yy = [yy(1)-dy*(padsize(1):-1:1), yy(:)', yy(end)+dy*(1:padsize(1))];
sz = size(img);

%% compute exact displacement field for specified displacements and boundary

u_exact = zeros(sz);
v_exact = zeros(sz);

% apply constant displacement
u_exact = u_exact + args.translation(1);
v_exact = v_exact + args.translation(2);

% apply simple shear in specified band
[xg, yg] = meshgrid(xx - mean(xx), yy - mean(yy));
rot = [cosd(args.shear_theta), sind(args.shear_theta); ...
       -sind(args.shear_theta), cosd(args.shear_theta)];
xy = [xg(:)'; yg(:)'];
xy = rot*xy;
yg(:) = xy(2,:);
scale = yg/args.shear_width;
scale(scale < -0.5) = -0.5;
scale(scale > 0.5) = 0.5;

u_exact = u_exact + scale*cosd(args.shear_theta)*args.shear_mag;
v_exact = v_exact + scale*sind(args.shear_theta)*args.shear_mag;

% compute ROI with sinusoidal upper boundary
bnd_mean = args.bnd_mean*range(yy);
bnd_ampl = args.bnd_ampl*range(yy);
bnd_freq = 2*pi/range(xx)*args.bnd_freq;
y_bnd = bnd_mean + bnd_ampl*sin(bnd_freq*xx);

[~, yg] = meshgrid(xx, yy);
roi = yg <= repmat(y_bnd(:)', numel(yy), 1);

% <DEBUG>
figure
mag = sqrt(u_exact.^2 + v_exact.^2);
imagesc(xx, yy, mag);
set(gca, 'YDir', 'Normal');
hold on;
[xg, yg] = meshgrid(xx, yy);
dd = 5;
quiver(xg(1:dd:end, 1:dd:end), yg(1:dd:end, 1:dd:end), ...
    u_exact(1:dd:end, 1:dd:end), v_exact(1:dd:end, 1:dd:end));
% </DEBUG>

%% generate synthetic images

% convert to pixel coords
u_exact_pix = u_exact/(range(xx)/length(xx));
v_exact_pix = v_exact/(range(yy)/length(yy));

% deform
ini = imwarp(img, 0.5*cat(3, u_exact_pix, v_exact_pix), 'cubic'); % dir is ok
fin = imwarp(img, -0.5*cat(3, u_exact_pix, v_exact_pix), 'cubic');

% reapply mask

% <DEBUG>
figure

subplot(1,2,1)
imagesc(ini)
set(gca, 'YDir', 'normal');
axis equal tight
title('ini')

subplot(1,2,2)
imagesc(fin)
set(gca, 'YDir', 'normal');
axis equal tight
title('fin')
% </DEBUG>

keyboard

%% run PIV on synthetic images

% TODO

%% analyze errors

% TODO

%% OLD

% 
% % local parameters
% data_file = 'test/image.mat';
% func_name = 'test_piv_run_image';
% 
% %% parse arguments and set defaults
% 
% narginchk(0,1);
% if nargin == 0 || isempty(force) 
%     force = 0;
% end
% 
% validateattributes(force, {'numeric'}, {'scalar', 'binary'});

% %% compute exact solution
% 
% %... deform initial grid
% [xgrid, ygrid] = meshgrid(xx, yy);
% [xgrid_defm, ygrid_defm] = test_piv_util_transform(tform, xgrid(:), ygrid(:), 1);
% xgrid_defm = reshape(xgrid_defm, size(uu));
% ygrid_defm = reshape(ygrid_defm, size(uu));
% 
% %... get displacements and thier location at midpoint time
% u_tm = xgrid_defm-xgrid;
% v_tm = ygrid_defm-ygrid;
% x_tm = 0.5*(xgrid_defm+xgrid);
% y_tm = 0.5*(ygrid_defm+ygrid);
% 
% % ... interpolate/extrapolate to image grid at midpoint time
% uu_exact = nan(size(xgrid));
% uu_exact(:) = spline2d(x_tm(:), y_tm(:), xgrid(:), ygrid(:), u_tm(:), 0.95);
% vv_exact = nan(size(xgrid));
% vv_exact(:) = spline2d(x_tm(:), y_tm(:), xgrid(:), ygrid(:), v_tm(:), 0.95);
%     
% 
% 
% %% generate (or load) test images
% 
% % check if defined parameters match saved parameters
% try
%     F = load(data_file, 'tform', 'bnd_mean', 'bnd_ampl', 'bnd_freq');
%     same = all(F.tform(:) == tform(:)) && ...
%         F.bnd_mean == bnd_mean && ...
%         F.bnd_ampl == bnd_ampl && ...
%         F.bnd_freq == bnd_freq;
% catch
%     same = 0;
% end
% 
% % report status
% if same 
%     fprintf('%s: Parameters are not modified\n', func_name); 
% else
%     fprintf('%s: Parameters are modified\n', func_name); 
% end
% if force
%     fprintf('%s: Force recompute enabled\n', func_name);
% else
%     fprintf('%s: Force recompute disabled\n', func_name);
% end
% 
% % load PIV input data
% if same && ~force
%     fprintf('%s: Loading input variables from file\n', func_name);
%     F = load(data_file, 'ini', 'ini_roi', 'fin', 'fin_roi', 'xx', 'yy');
%     ini = F.ini;
%     ini_roi = F.ini_roi;
%     fin = F.fin;
%     fin_roi = F.fin_roi;
%     xx = F.xx;
%     yy = F.yy;
%     
% else
%     fprintf('%s: Generating new input variables\n', func_name);
%     [ini, fin, ini_roi, fin_roi, xx, yy] = ...
%         test_piv_create_image(tform, bnd_mean, bnd_ampl, bnd_freq);
%     save(data_file, 'tform', 'bnd_mean', 'bnd_ampl', 'bnd_freq', 'ini', ...
%             'ini_roi', 'fin', 'fin_roi', 'xx', 'yy');
% end
% 
% clear F
% 
% %% run PIV and analyze results
% 
% % run piv
% [xx, yy, uu, vv] = piv(ini, fin, ini_roi, fin_roi, xx, yy, samplen, ...
%     sampspc, intrlen, npass, valid_max, valid_eps, spline_tension, ...
%     min_frac_data, min_frac_overlap, 1);
% 
% % % TODO: Results indicate exact and computed solutions are off by one. Which is
% % %   wrong?
% % uu = uu-1;
% % vv = vv-1;
% 
% % compute errors
% uu_error = uu-uu_exact;
% vv_error = vv-vv_exact;
% 
% % compute strain
% strain = post_strain(xx, yy, uu, vv, ~isnan(uu), 'nearest');
% 
% % print and plot standard results
% test_piv_util_print_error(uu_error, vv_error);
% test_piv_util_plot_error(uu_error, vv_error);
% test_piv_util_plot(xx, yy, uu, vv, sqrt(uu.^2, vv.^2), strain.Dd);
